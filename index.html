// Motor de backtesting para testar estratégias em dados históricos

const BacktestEngine = {
    strategies: {
        // Estratégia 1: RSI + MACD Confluence
        rsi_macd: (data, index, indicators) => {
            const { rsi, macd } = indicators;
            if (index < 26) return null; // mínimo de dados
            
            const currentRSI = rsi[index]?.value;
            const currentMACD = macd.macdLine[index]?.value;
            const currentSignal = macd.signalLine[index]?.value;
            const prevMACD = macd.macdLine[index-1]?.value;
            const prevSignal = macd.signalLine[index-1]?.value;
            
            if (!currentRSI || !currentMACD || !currentSignal) return null;
            
            // Sinal de compra: RSI < 40 e MACD cruza acima do sinal
            const macdCrossUp = prevMACD <= prevSignal && currentMACD > currentSignal;
            if (currentRSI < 40 && macdCrossUp) return 'BUY';
            
            // Sinal de venda: RSI > 60 e MACD cruza abaixo do sinal
            const macdCrossDown = prevMACD >= prevSignal && currentMACD < currentSignal;
            if (currentRSI > 60 && macdCrossDown) return 'SELL';
            
            return null;
        },
        
        // Estratégia 2: Bollinger Breakout
        bollinger_breakout: (data, index, indicators) => {
            const { bollinger } = indicators;
            if (index < 20) return null;
            
            const currentPrice = data[index].close;
            const upper = bollinger.upper[index]?.value;
            const lower = bollinger.lower[index]?.value;
            const middle = bollinger.middle[index]?.value;
            
            if (!upper || !lower) return null;
            
            // Compra: toca banda inferior e reverte
            if (currentPrice <= lower * 1.01) return 'BUY';
            
            // Venda: toca banda superior
            if (currentPrice >= upper * 0.99) return 'SELL';
            
            return null;
        },
        
        // Estratégia 3: Golden Cross
        golden_cross: (data, index, indicators) => {
            const { sma20, sma50 } = indicators;
            if (index < 50) return null;
            
            const currentSMA20 = sma20[index]?.value;
            const currentSMA50 = sma50[index]?.value;
            const prevSMA20 = sma20[index-1]?.value;
            const prevSMA50 = sma50[index-1]?.value;
            
            if (!currentSMA20 || !currentSMA50) return null;
            
            // Cruzamento de alta: SMA20 cruza acima da SMA50
            if (prevSMA20 <= prevSMA50 && currentSMA20 > currentSMA50) return 'BUY';
            
            // Cruzamento de baixa
            if (prevSMA20 >= prevSMA50 && currentSMA20 < currentSMA50) return 'SELL';
            
            return null;
        }
    },

    run(data, strategyName, config) {
        const results = {
            trades: [],
            equity: [config.initialCapital],
            totalReturn: 0,
            winRate: 0,
            maxDrawdown: 0
        };
        
        let capital = config.initialCapital;
        let position = null; // { type: 'LONG'|'SHORT', entry: price, size: amount }
        let peak = capital;
        
        // Calcular indicadores uma vez
        const indicators = {
            rsi: TechnicalAnalysis.calculateRSI(data),
            macd: TechnicalAnalysis.calculateMACD(data),
            bollinger: TechnicalAnalysis.calculateBollinger(data),
            sma20: TechnicalAnalysis.calculateSMA(data, 20),
            sma50: TechnicalAnalysis.calculateSMA(data, 50),
            atr: TechnicalAnalysis.calculateATR(data)
        };
        
        const strategy = this.strategies[strategyName];
        
        for (let i = 50; i < data.length; i++) {
            const candle = data[i];
            const signal = strategy(data, i, indicators);
            
            // Gerenciamento de posição aberta
            if (position) {
                const pnlPercent = position.type === 'LONG' 
                    ? ((candle.close - position.entry) / position.entry) * 100
                    : ((position.entry - candle.close) / position.entry) * 100;
                
                // Checar Stop Loss ou Take Profit
                const hitStop = pnlPercent <= -config.stopLoss;
                const hitTarget = pnlPercent >= config.takeProfit;
                
                if (hitStop || hitTarget || signal === 'SELL') {
                    // Fechar posição
                    const pnl = (capital * (pnlPercent / 100)) * (config.leverage || 1);
                    capital += pnl;
                    
                    results.trades.push({
                        type: position.type,
                        entry: position.entry,
                        exit: candle.close,
                        pnl: pnl,
                        pnlPercent: pnlPercent,
                        result: pnl > 0 ? 'WIN' : 'LOSS',
                        exitReason: hitStop ? 'STOP' : hitTarget ? 'TARGET' : 'SIGNAL'
                    });
                    
                    position = null;
                    results.equity.push(capital);
                    
                    if (capital > peak) peak = capital;
                    const drawdown = ((peak - capital) / peak) * 100;
                    if (drawdown > results.maxDrawdown) results.maxDrawdown = drawdown;
                }
            }
            
            // Abrir nova posição
            if (!position && signal === 'BUY') {
                position = {
                    type: 'LONG',
                    entry: candle.close,
                    size: capital * 0.95 // 95% do capital (reserva para fees)
                };
            }
        }
        
        // Calcular métricas finais
        results.totalReturn = ((capital - config.initialCapital) / config.initialCapital) * 100;
        const wins = results.trades.filter(t => t.result === 'WIN').length;
        results.winRate = results.trades.length > 0 ? (wins / results.trades.length) * 100 : 0;
        results.finalCapital = capital;
        
        return results;
    }
};
